/*
 *   Copyright 2014 Calytrix Technologies
 *
 *   This file is part of wantest.
 *
 *   NOTICE:  All information contained herein is, and remains
 *            the property of Calytrix Technologies Pty Ltd.
 *            The intellectual and technical concepts contained
 *            herein are proprietary to Calytrix Technologies Pty Ltd.
 *            Dissemination of this information or reproduction of
 *            this material is strictly forbidden unless prior written
 *            permission is obtained from Calytrix Technologies Pty Ltd.
 *
 *   Unless required by applicable law or agreed to in writing,
 *   software distributed under the License is distributed on an
 *   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *   KIND, either express or implied.  See the License for the
 *   specific language governing permissions and limitations
 *   under the License.
 */
package wantest.latency;

import org.apache.log4j.Logger;

import hla.rti1516e.ParameterHandleValueMap;
import hla.rti1516e.RTIambassador;
import hla.rti1516e.exceptions.RTIexception;
import static wantest.Handles.*;
import wantest.FederateAmbassador;
import wantest.IDriver;
import wantest.Storage;
import wantest.Utils;
import wantest.config.Configuration;
import wantest.config.LoggingConfigurator;
import wantest.events.LatencyEvent;

public class LatencyDriver implements IDriver
{
	//----------------------------------------------------------
	//                    STATIC VARIABLES
	//----------------------------------------------------------

	//----------------------------------------------------------
	//                   INSTANCE VARIABLES
	//----------------------------------------------------------
	private Logger logger;
	private Configuration configuration;
	private RTIambassador rtiamb;
	private FederateAmbassador fedamb;
	private Storage storage;
	
	// execution parameters
	private byte[] payload;

	//----------------------------------------------------------
	//                      CONSTRUCTORS
	//----------------------------------------------------------

	//----------------------------------------------------------
	//                    INSTANCE METHODS
	//----------------------------------------------------------

	public void execute( Configuration configuration,
	                     RTIambassador rtiamb,
	                     FederateAmbassador fedamb,
	                     Storage storage )
	    throws RTIexception
	{
		logger = LoggingConfigurator.getLogger( configuration.getFederateName() );
		this.configuration = configuration;
		this.rtiamb = rtiamb;
		this.fedamb = fedamb;
		this.storage = storage;
		
		// execution parameters
		this.payload = Utils.generatePayload( configuration.getPacketSize() );

		logger.info( " ================================" );
		logger.info( " =     Running Latency Test     =" );
		logger.info( " ================================" );
		String sizeString = Utils.getSizeString( configuration.getPacketSize() );
		logger.info( "Minimum message size="+sizeString );
		logger.info( "Sender/Receiver: "+(configuration.isLatencySender() ? "SENDER":"RECIEVER") );
		
		// Confirm that everyone is ready to proceed
		this.waitForStart();
		
		// Loop
		for( int i = 0; i < configuration.getLoopCount(); i++ )
		{
			if( configuration.isLatencySender() )
				sendInteractionAndWait( i );
			else
				respondToInteractions( i );

			// print where we're up to every now and then
			if( (i+1) % ((int)configuration.getLoopCount()*0.1) == 0 )
				logger.info( "Finished loop ["+(i+1)+"]" );
		}

		// Confirm that everyone is ready to complete
		this.waitForFinish();

		logger.info( "Latency Test Finished" );
		logger.info( "" );
		
		// Print the report - but only if we were the sender
		if( configuration.isLatencySender() )
			new LatencyReportGenerator(storage).printReport();
		else
			logger.info( "Report has been generated by sender federate" );
	}

	////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////// Loop ///////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * It's our turn to initiate the test. Send an interaction and then wait for all the
	 * responses to filter back in before advancing time. 
	 */
	private void sendInteractionAndWait( int serial ) throws RTIexception
	{
		ParameterHandleValueMap parameters = rtiamb.getParameterHandleValueMapFactory().create( 3 );
		parameters.put( PC_PING_SERIAL, Utils.intToBytes(serial) );
		parameters.put( PC_PING_SENDER, configuration.getFederateName().getBytes() );
		parameters.put( PC_PING_PAYLOAD, payload );
		
		// setup the event and store in fedamb so we can record pings
		int responseCount = configuration.getPeers().size();
		LatencyEvent event = new LatencyEvent( serial, responseCount, payload.length );
		
		// store the event information
		storage.addLatencyEvent( event );
		fedamb.currentLatencyEvent = event;

		// send the interaction!
		event.setSentTimestamp( System.nanoTime() );
		rtiamb.sendInteraction( IC_PING, parameters, null );
		
		// wait until we have all the responses before we request a time advance
		do
		{
			rtiamb.evokeCallback( configuration.getLoopWait() / 1000.0f );
		}
		while( event.hasReceivedAllResponses() == false );

		// clear the current fedamb event so we're don't mistakenly thing we are still processing
		fedamb.currentLatencyEvent = null;
	}

	/**
	 * It's someone elses turn to initiate the test. Monitor the fedamb for the incoming
	 * request and respond as quickly as possible. Once we've responded, request a time
	 * advance so that all our homies can sync up. We won't get the advance until the
	 * requesting federate has all its responses, which should bring us all into step.
	 */
	private void respondToInteractions( int serial ) throws RTIexception
	{
		if( configuration.isEvokedCallback() )
		{
			while( fedamb.pingReceived.contains(serial) == false )
				rtiamb.evokeCallback( configuration.getLoopWait() );
		}
		else
		{
			synchronized( fedamb.pingSignal )
			{
				while( fedamb.pingReceived.contains(serial) == false )
					Utils.wait( fedamb.pingSignal );
			}
		}
		
		// we have been summoned - respond
		ParameterHandleValueMap parameters = rtiamb.getParameterHandleValueMapFactory().create( 3 );
		parameters.put( PC_PING_ACK_SERIAL, Utils.intToBytes(serial) );
		parameters.put( PC_PING_ACK_SENDER, configuration.getFederateName().getBytes() );
		parameters.put( PC_PING_ACK_PAYLOAD, payload );
		rtiamb.sendInteraction( IC_PING_ACK, parameters, null );
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////// Lifecycle Methods /////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////
	private void waitForStart() throws RTIexception
	{
		while( fedamb.announcedSyncPoints.contains("START_LATENCY_TEST") == false )
			tickOrSleep();
		
		// achieve the ready-to-start sync point
		rtiamb.synchronizationPointAchieved( "START_LATENCY_TEST" );
		
		// wait for everyone to do the same
		while( fedamb.achievedSyncPoints.contains("START_LATENCY_TEST") == false )
			tickOrSleep();
	}

	private void waitForFinish() throws RTIexception
	{
		while( fedamb.announcedSyncPoints.contains("FINISH_LATENCY_TEST") == false )
			tickOrSleep();
		
		rtiamb.synchronizationPointAchieved( "FINISH_LATENCY_TEST" );

		// wait for everyone to do the same
		while( fedamb.achievedSyncPoints.contains("FINISH_LATENCY_TEST") == false )
			rtiamb.evokeMultipleCallbacks( 0.1, 1.0 );
	}
	
	private void tickOrSleep() throws RTIexception
	{
		if( configuration.isImmediateCallback() )
			Utils.sleep( configuration.getLoopWait() );
		else
			rtiamb.evokeMultipleCallbacks( configuration.getLoopWait(), configuration.getLoopWait() );
	}
	
	public String getName()
	{
		return "Latency Test";
	}

	//----------------------------------------------------------
	//                     STATIC METHODS
	//----------------------------------------------------------
}
